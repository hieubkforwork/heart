<!DOCTYPE html>
<html>
  <head>
    <title>Heart for NH</title>
    <meta charset="utf-8" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
        height: 100%;
        width: 100%;
      }

      canvas {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
      }

      #bg-text {
        position: fixed;
        top: 95%;
        left: 90%;
        transform: translate(-50%, -50%);
        font-family: "Satisfy", cursive;
        font-size: 30px;
        color: #ffffff;
        text-shadow: 0 0 20px #ff3366, 0 0 40px #ff6699;
        opacity: 0.9;
        animation: glow 3s ease-in-out infinite;
        pointer-events: none;
        z-index: 3;
      }

      @keyframes glow {
        0%, 100% {
          text-shadow: 0 0 10px #ff4d6d, 0 0 20px #ff8099, 0 0 30px #ff4d6d;
          opacity: 0.8;
        }
        50% {
          text-shadow: 0 0 30px #ff99cc, 0 0 60px #ff4d6d, 0 0 100px #ff1a66;
          opacity: 1;
        }
      }
    </style>
  </head>

  <body>
    <div id="bg-text">For NH</div>
    <canvas id="heart"></canvas>
    <canvas id="draw-layer"></canvas>

    <script>
      const canvas = document.getElementById("heart");
      const ctx = canvas.getContext("2d");

      const drawCanvas = document.getElementById("draw-layer");
      const dctx = drawCanvas.getContext("2d");

      let width = (canvas.width = drawCanvas.width = innerWidth);
      let height = (canvas.height = drawCanvas.height = innerHeight);

      let drawing = false;
      let mouseX = width / 2;
      let mouseY = height / 2;
      let prevX = 0, prevY = 0;

      // Lưu các bước vẽ để undo
      const history = [];
      const maxHistory = 50;

      function saveState() {
        if (history.length >= maxHistory) history.shift();
        history.push(dctx.getImageData(0, 0, width, height));
      }

      function undo() {
        if (history.length > 0) {
          const prev = history.pop();
          dctx.putImageData(prev, 0, 0);
        }
      }

      window.addEventListener("resize", () => {
        width = canvas.width = drawCanvas.width = innerWidth;
        height = canvas.height = drawCanvas.height = innerHeight;
      });

      // --- Điều khiển chuột ---
      window.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        if (drawing) {
          dctx.strokeStyle = "rgba(255,180,200,0.9)";
          dctx.shadowBlur = 25;
          dctx.shadowColor = "#ff66aa";
          dctx.lineWidth = 3;
          dctx.lineCap = "round";
          dctx.beginPath();
          dctx.moveTo(prevX, prevY);
          dctx.lineTo(mouseX, mouseY);
          dctx.stroke();
        }
        prevX = mouseX;
        prevY = mouseY;
      });

      document.addEventListener("contextmenu", (e) => e.preventDefault());
      click = 1;
      document.addEventListener("mousedown", (e) => {
        click = 1.2;
        if (e.button === 0) {
          saveState(); // Lưu trước khi bắt đầu vẽ
          drawing = true;
          prevX = mouseX;
          prevY = mouseY;
        } else if (e.button === 2) {
          dctx.clearRect(0, 0, width, height);
          history.length = 0;
        }
      });

      document.addEventListener("mouseup", () => {
        click = 1;
        drawing = false;
      });

      // --- Ctrl+Z ---
      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && e.key.toLowerCase() === "z") {
          undo();
        }
      });

      // --- Hiệu ứng tim ---
      const rand = Math.random;
      const heartPosition = (rad) => [
        Math.pow(Math.sin(rad), 3),
        -(
          15 * Math.cos(rad) -
          5 * Math.cos(2 * rad) -
          2 * Math.cos(3 * rad) -
          Math.cos(4 * rad)
        ),
      ];
      const scaleAndTranslate = (pos, sx, sy, dx, dy) => [
        dx + pos[0] * sx,
        dy + pos[1] * sy,
      ];

      const pointsOrigin = [];
      const dr = 0.1;
      for (let i = 0; i < Math.PI * 2; i += dr)
        pointsOrigin.push(scaleAndTranslate(heartPosition(i), 210, 13, 0, 0));
      for (let i = 0; i < Math.PI * 2; i += dr)
        pointsOrigin.push(scaleAndTranslate(heartPosition(i), 150, 9, 0, 0));
      for (let i = 0; i < Math.PI * 2; i += dr)
        pointsOrigin.push(scaleAndTranslate(heartPosition(i), 90, 5, 0, 0));

      const heartPointsCount = pointsOrigin.length;
      const targetPoints = [];
      const pulse = (kx, ky) => {
        for (let i = 0; i < pointsOrigin.length; i++) {
          targetPoints[i] = [
            pointsOrigin[i][0] * kx * click + mouseX,
            pointsOrigin[i][1] * ky * click + mouseY,
          ];
        }
      };

      const e = [];
      const traceCount = 50;
      for (let i = 0; i < heartPointsCount; i++) {
        const x = rand() * width;
        const y = rand() * height;
        e[i] = {
          vx: 0,
          vy: 0,
          speed: rand() + 5,
          q: ~~(rand() * heartPointsCount),
          D: 2 * (i % 2) - 1,
          force: 0.2 * rand() + 0.7,
          f: `hsla(${~~(rand() * 10 + 340)}, ${~~(60 * rand() + 40)}%, ${~~(
            50 * rand() +
            30
          )}%, .4)`,
          trace: Array.from({ length: traceCount }, () => ({
            x,
            y,
          })),
        };
      }

      const config = { traceK: 0.4, timeDelta: 0.01 };
      let time = 0;

      const loop = () => {
          const n = -Math.cos(time);
          pulse((1 + n) * 0.5, (1 + n) * 0.5);
          time +=
            (Math.sin(time) < 0 ? 9 : n > 0.8 ? 0.2 : 1) * config.timeDelta;

          ctx.fillStyle = "rgba(0,0,0,0.1)";
          ctx.fillRect(0, 0, width, height);

          for (let i = e.length; i--; ) {
            const u = e[i];
            const q = targetPoints[u.q];
            const dx = u.trace[0].x - q[0];
            const dy = u.trace[0].y - q[1];
            const length = Math.sqrt(dx * dx + dy * dy);

            if (10 > length) {
              if (0.95 < rand()) u.q = ~~(rand() * heartPointsCount);
              else {
                if (0.99 < rand()) u.D *= -1;
                u.q += u.D;
                u.q %= heartPointsCount;
                if (u.q < 0) u.q += heartPointsCount;
              }
            }

            u.vx += (-dx / length) * u.speed;
            u.vy += (-dy / length) * u.speed;
            u.trace[0].x += u.vx;
            u.trace[0].y += u.vy;
            u.vx *= u.force;
            u.vy *= u.force;

            for (let k = 0; k < u.trace.length - 1; ) {
              const T = u.trace[k];
              const N = u.trace[++k];
              N.x -= config.traceK * (N.x - T.x);
              N.y -= config.traceK * (N.y - T.y);
            }

            ctx.fillStyle = u.f;
            for (let k = 0; k < u.trace.length; k++)
              ctx.fillRect(u.trace[k].x, u.trace[k].y, 1, 1);
          }
    

        requestAnimationFrame(loop);
      };

      loop();
    </script>
  </body>
</html>
